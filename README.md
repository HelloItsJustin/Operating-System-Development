{"name": "README.md", "type": "document", "content": "# 🧠 Jetson Operating System\n\n<p align="center">\n <img src="screenshot.png" alt="OS Boot Screen" width="500"/>\n</p>\n\n<p align="center">\n <img src="screenshot1.png" alt="Memory Map Log" width="500"/>\n</p>\n\nA bootable x86 operating system built from scratch using Assembly and C, following a structured step-by-step OS development guide. \nIncludes a custom bootloader, FAT12 filesystem loader, memory logging display, VGA output, and printf() support—all running inside QEMU.\n\n> Author / Maintainer: Justin Thomas\n\n---\n\n## 📌 Overview\n\nThis project is a hands-on exploration of low-level systems programming and OS internals. By implementing each component—from the 16-bit bootloader to the C-based kernel—you gain a deep understanding of how hardware and software interact at the bare-metal level.\n\n---\n\n## 🛠️ Features Implemented\n\n| Feature | Description |\n|-----------------------------|-----------------------------------------------------------------------------|\n| ✅ Bootloader | Custom BIOS-compatible bootloader in Assembly |\n| ✅ Disk Reading (INT 13h) | Sector-based disk access using BIOS interrupts |\n| ✅ FAT12 Filesystem | FAT12 support with subdirectory traversal |\n| ✅ Kernel in C | Bootloader hands control to a C-based kernel |\n| ✅ printf() | Minimal printf() implemented using va_list for formatting |\n| ✅ VGA Text Output | Writes text in real mode via VGA buffer (0xB8000) |\n| ✅ Memory Log Display | Displays BIOS-provided memory map and diagnostics on boot |\n| ✅ Build System | Automated with SCons |\n| ✅ QEMU Integration | Bootable disk image tested in QEMU |\n\n---\n\n## 📂 Directory Structure\n\n\n.\n├── bootloader/ # Stage1 & Stage2 bootloader (ASM + C)\n├── kernel/ # Core kernel code (C and ASM)\n├── fs/ # FAT12 parsing library\n├── libs/ # Minimal stdio, string, and utility libraries\n├── toolchain/ # GCC cross-compiler setup scripts\n├── image/ # SCons scripts for disk formatting & mounting\n├── build/ # Output: kernel.elf and image.img\n├── scripts/ # run.sh to launch QEMU\n├── SConstruct # Top-level SCons build script\n└── README.md # This file\n\n\n---\n\n## ⚙️ Development Environment\n\n- OS: Ubuntu (via WSL or native Linux) \n- Compiler Toolchain: Custom i686-elf-gcc cross-compiler \n- Emulator: QEMU (qemu-system-i386) \n- Image Tools: libguestfs, guestmount, supermin \n- Build System: SCons\n\n---\n\n## 🧪 Setup & Usage\n\n1. Install toolchain \n bash\n cd toolchain\n bash setup.sh\n \n\n2. Build the OS \n bash\n scons\n \n\n3. Run in QEMU \n bash\n sudo ./scripts/run.sh disk build/i686_debug/image.img\n \n Note: sudo is required for guestmount during image creation.\n\n---\n\n## 🧠 Concepts Demonstrated\n\n- BIOS interrupt programming (INT 13h, INT 10h) \n- Real-mode to protected-mode bootstrapping \n- Sector I/O and FAT12 filesystem parsing \n- Memory-mapped VGA text rendering \n- Custom printf() with variable arguments \n- BIOS memory map logging and display \n- Bare-metal C kernel without libc \n- Automated image creation and QEMU testing\n\n---\n\n## 🎯 Planned Future Additions\n\n- ⌨️ PS/2 keyboard input and interrupt handling \n- 🐚 Basic shell interface (CLI) \n- 📦 Dynamic memory allocator (heap and paging) \n- 🧱 Protected-mode enhancements \n- 🔁 Simple task scheduler for multitasking\n\n---\n\n## ✅ What I’ve Learned\n\n- End-to-end OS bootloader and kernel startup \n- Low-level disk I/O and filesystem implementation \n- BIOS interrupt interaction \n- Implementing a minimal C runtime and printf() \n- Debugging bare-metal code with QEMU and E9 serial output \n- Build automation for cross-platform bare-metal development\n\n---\n\n## 📝 License\n\nThis project is developed and maintained by Justin Thomas for educational purposes.\n\n---\n\n## 🔍 Acknowledgements\n\nInspired by community tutorials and open-source OSDev resources. Special thanks to all authors and contributors whose guides made this learning journey possible.\n"}